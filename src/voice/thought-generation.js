/**
 * The Tribunal - Thought Generation
 * 
 * AI-powered custom thought creation for the Thought Cabinet.
 * Generates Disco Elysium-style thoughts based on chat context,
 * player persona, and tracked themes.
 * 
 * Lives in voice/ because it shares API infrastructure with voice generation.
 */

import { SKILLS } from '../data/skills.js';
import { getChatState, getSettings } from '../core/state.js';
import { 
    addCustomThought, 
    getTopThemes, 
    getPlayerContext,
    getThemeCounters 
} from '../systems/cabinet.js';
import { 
    buildThoughtSystemPrompt, 
    buildThoughtUserPrompt, 
    parseThoughtResponse 
} from './thought-prompt-builder.js';
import { callAPI } from './api-helpers.js';

// ═══════════════════════════════════════════════════════════════
// THOUGHT GENERATION
// ═══════════════════════════════════════════════════════════════

/**
 * Generate a custom thought via AI
 * @param {object} options
 * @param {string} options.concept - User-provided concept (optional)
 * @param {boolean} options.fromContext - Include recent chat context
 * @param {string} options.perspective - Override perspective ('observer'|'participant')
 * @param {string} options.playerIdentity - Override player identity
 * @param {string} options.lorebookContext - Additional lorebook context
 * @returns {object|null} Generated thought or null on failure
 */
export async function generateThought(options = {}) {
    const {
        concept = '',
        fromContext = true,
        perspective = null,
        playerIdentity = null,
        lorebookContext = ''
    } = options;
    
    const state = getChatState();
    if (!state) {
        console.error('[Tribunal] Cannot generate thought - no chat state');
        return null;
    }
    
    // Get context from chat if requested
    let contextText = '';
    if (fromContext) {
        try {
            // Try to get SillyTavern context
            const stContext = window.SillyTavern?.getContext?.() || window.getContext?.();
            if (stContext?.chat) {
                const recentMessages = stContext.chat.slice(-5) || [];
                contextText = recentMessages.map(m => m.mes).join('\n\n');
            }
        } catch (e) {
            console.warn('[Tribunal] Could not get chat context:', e);
        }
    }
    
    if (!concept && !contextText) {
        throw new Error('Enter a concept or enable "From chat"');
    }
    
    // Get player context (auto-detects perspective from POV)
    const defaultPlayerContext = getPlayerContext();
    const playerContext = {
        perspective: perspective || defaultPlayerContext.perspective,
        identity: playerIdentity || defaultPlayerContext.identity
    };
    
    // Get theme data
    const themeData = getThemeCounters();
    
    // Build prompts
    const systemPrompt = buildThoughtSystemPrompt(playerContext, themeData);
    const userPrompt = buildThoughtUserPrompt(
        concept, 
        contextText, 
        {
            autoGenerated: !concept,
            triggeringThemes: getTopThemes(3).map(t => t.name),
            lorebookContext
        }
    );
    
    console.log('[Tribunal] Generating thought...');
    console.log('[Tribunal] Perspective:', playerContext.perspective);
    console.log('[Tribunal] Identity:', playerContext.identity || '(none)');
    console.log('[Tribunal] Top themes:', getTopThemes(3).map(t => t.name).join(', '));
    
    try {
        // Call the API
        const response = await callAPI(systemPrompt, userPrompt);
        
        console.log('[Tribunal] Raw response length:', response?.length);
        
        // Parse the response
        const thought = parseThoughtResponse(response);
        
        if (!thought) {
            throw new Error('Failed to parse thought from API response');
        }
        
        console.log('[Tribunal] Generated thought:', thought.name);
        return thought;
        
    } catch (error) {
        console.error('[Tribunal] Thought generation failed:', error);
        throw error;
    }
}


// ═══════════════════════════════════════════════════════════════
// HIGH-LEVEL HANDLERS
// ═══════════════════════════════════════════════════════════════

/**
 * Generate and add a thought to the cabinet
 * Full flow: generate -> parse -> add to discovered
 * @param {object} options - Same as generateThought
 * @param {function} onSuccess - Callback with thought
 * @param {function} onError - Callback with error
 * @returns {object|null} Added thought
 */
export async function generateAndAddThought(options = {}, onSuccess = null, onError = null) {
    try {
        const thought = await generateThought(options);
        
        if (!thought) {
            throw new Error('Generation returned empty');
        }
        
        // Add to cabinet
        const addedThought = addCustomThought(thought);
        
        if (!addedThought) {
            throw new Error('Failed to add thought to cabinet');
        }
        
        console.log('[Tribunal] Added thought:', addedThought.name, 'ID:', addedThought.id);
        
        if (onSuccess) {
            onSuccess(addedThought);
        }
        
        return addedThought;
        
    } catch (error) {
        console.error('[Tribunal] generateAndAddThought failed:', error);
        
        if (onError) {
            onError(error);
        }
        
        return null;
    }
}


// ═══════════════════════════════════════════════════════════════
// LOREBOOK INTEGRATION
// ═══════════════════════════════════════════════════════════════

/**
 * Try to extract relevant lorebook entries for thought generation
 * @param {string} concept - The concept being explored
 * @returns {string} Formatted lorebook context
 */
export function extractLorebookContext(concept) {
    try {
        const stContext = window.SillyTavern?.getContext?.() || window.getContext?.();
        
        if (!stContext?.characters) {
            return '';
        }
        
        // Get current character's lorebook if available
        const char = stContext.characters?.[stContext.characterId];
        if (!char) {
            return '';
        }
        
        // Build context from character description and personality
        let context = '';
        
        if (char.description) {
            context += `Character Description:\n${char.description.substring(0, 500)}\n\n`;
        }
        
        if (char.personality) {
            context += `Character Personality:\n${char.personality.substring(0, 300)}\n\n`;
        }
        
        return context;
        
    } catch (e) {
        console.warn('[Tribunal] Could not extract lorebook context:', e);
        return '';
    }
}


// ═══════════════════════════════════════════════════════════════
// UI HANDLER (for panel integration)
// ═══════════════════════════════════════════════════════════════

/**
 * Handle Generate Thought button click
 * Called from cabinet UI
 * @param {object} formData - { concept, fromContext, perspective, playerIdentity }
 * @param {function} refreshCabinetTab - Callback to refresh UI
 * @param {function} showToast - Toast notification function
 * @returns {object|null}
 */
export async function handleGenerateThought(formData, refreshCabinetTab, showToast) {
    const { concept, fromContext, perspective, playerIdentity } = formData;
    
    if (showToast) {
        showToast('Generating thought...', 'info', 5000);
    }
    
    try {
        // Try to get lorebook context
        const lorebookContext = extractLorebookContext(concept);
        
        const thought = await generateAndAddThought({
            concept,
            fromContext,
            perspective,
            playerIdentity,
            lorebookContext
        });
        
        if (thought) {
            if (showToast) {
                showToast(`Discovered: ${thought.name}`, 'success');
            }
            
            if (refreshCabinetTab) {
                refreshCabinetTab();
            }
            
            return thought;
        } else {
            if (showToast) {
                showToast('Generation failed', 'error');
            }
        }
        
    } catch (error) {
        const errorMsg = error.message || 'Unknown error';
        
        if (showToast) {
            showToast(`Failed: ${errorMsg.substring(0, 50)}`, 'error');
        }
        
        console.error('[Tribunal] handleGenerateThought error:', error);
    }
    
    return null;
}


// ═══════════════════════════════════════════════════════════════
// AUTO-SUGGEST (Future feature)
// ═══════════════════════════════════════════════════════════════

/**
 * Check if conditions are right to suggest a thought
 * @returns {boolean}
 */
export function shouldSuggestThought() {
    const topThemes = getTopThemes(1);
    
    if (topThemes.length > 0 && topThemes[0].count >= 10) {
        return true;
    }
    
    return false;
}

/**
 * Get suggested thought prompt based on current themes
 * @returns {string|null}
 */
export function getSuggestedPrompt() {
    const topThemes = getTopThemes(3);
    
    if (topThemes.length === 0) {
        return null;
    }
    
    const themeNames = topThemes.map(t => t.name.toLowerCase());
    
    if (themeNames.includes('death') && themeNames.includes('identity')) {
        return "What dies when you forget who you were?";
    }
    
    if (themeNames.includes('love') && themeNames.includes('failure')) {
        return "Why do you keep reaching for what always slips away?";
    }
    
    if (themeNames.includes('violence') && themeNames.includes('authority')) {
        return "Is force the only language that matters?";
    }
    
    const topTheme = topThemes[0].name;
    return `What does ${topTheme.toLowerCase()} mean to someone like you?`;
}
