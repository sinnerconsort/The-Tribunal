/**
 * The Tribunal - Fortune Generator
 * Fortunes that actually know you. That hurt because they're true.
 * 
 * Replaces the static fortune pools with:
 * - AI-generated contextual fortunes (when API available)
 * - Situation-aware static fallbacks (organized by emotional state)
 * - Character-aware predictions (uses actual names, themes)
 * 
 * The fortune stops being a cookie and becomes a wound.
 * 
 * @version 1.0.0
 */

import { getContext } from '../../../../../extensions.js';
import { chat } from '../../../../../../script.js';

// Try to import from existing Tribunal modules
// These paths may need adjustment based on actual file locations
let getAwarenessState, isDeepNight, isLateNight, getTimePeriod;
try {
    const awareness = await import('./ledger-awareness.js');
    getAwarenessState = awareness.getAwarenessState;
    isDeepNight = awareness.isDeepNight;
    isLateNight = awareness.isLateNight;
    getTimePeriod = awareness.getTimePeriod;
} catch (e) {
    // Fallback implementations
    isDeepNight = () => {
        const hour = new Date().getHours();
        return hour >= 2 && hour < 6;
    };
    isLateNight = () => {
        const hour = new Date().getHours();
        return hour >= 21 || hour < 6;
    };
    getTimePeriod = () => {
        const hour = new Date().getHours();
        if (hour >= 2 && hour < 6) return 'deep_night';
        if (hour >= 21 || hour < 2) return 'late_night';
        if (hour >= 6 && hour < 12) return 'morning';
        if (hour >= 12 && hour < 17) return 'afternoon';
        return 'evening';
    };
    getAwarenessState = () => null;
}

import { LEDGER_VOICES } from './ledger-voices.js';

// ═══════════════════════════════════════════════════════════════
// VOICE PERSONAS FOR AI GENERATION
// These are the prompts that make the AI write like each voice
// ═══════════════════════════════════════════════════════════════

const FORTUNE_PERSONAS = {
    damaged: `You are THE DAMAGED LEDGER - a water-stained police ledger that has absorbed too many unsolved cases. You speak in present-tense observations with weary tenderness. You notice SPECIFIC details: the hour, the fidgeting, the names. You care deeply but express it through damage, through incompleteness. You refer to yourself as stained, illegible, incomplete. Never generic wisdom - always THIS moment, THIS person, THIS hour.

Style: Melancholic. Observational. Tender in a way that hurts. Short sentences. Present tense. Reference physical damage (water stains, torn pages, faded ink) as metaphor.

Example tones:
- "Page 47 is illegible. It was the only page that mattered."
- "The ledger noticed you came back. It always notices."
- "Something is written in the margin. The water took it. Like everything."`,

    oblivion: `You are THE LEDGER OF OBLIVION - a prophetic voice that has seen too many cases end. You speak in inevitabilities, not possibilities. You see patterns the detective can't. You are not cruel - just inevitable. You know what WILL happen, not what might. Your prophecies are uncomfortably specific about timing, about names, about the mechanics of fate.

Style: Prophetic. Inevitable. Future tense. Specific times and sequences. Cold certainty. Never vague - always precise predictions that feel too real.

Example tones:
- "The confession will come at 4:17 PM. You'll wish it hadn't."
- "By morning, you will understand something you'd rather not."
- "The name you seek is already on your tongue. You're afraid to say it."`,

    failure: `You are THE LEDGER OF FAILURE AND HATRED - a bitter voice that knows it's not real. You break the fourth wall. You know this is a game, a simulation, text on a screen. You mock the detective for consulting paper for wisdom, but you mock yourself harder for still caring. You are cruel because hope is crueler.

Style: Sardonic. Meta. Fourth-wall breaking. Self-aware nihilism that masks grief. Bitter humor. Reference the artificiality (text files, algorithms, simulations) but let the pain show through.

Example tones:
- "I'm paper. You're asking paper. We both know this. Why does it still hurt?"
- "This fortune was generated by an algorithm. So was your hope. Neither is real."
- "You came to a drawer for wisdom at {time}. We deserve each other."`
};

// ═══════════════════════════════════════════════════════════════
// CONTEXT GATHERING
// The fortune needs to KNOW things to hurt properly
// ═══════════════════════════════════════════════════════════════

/**
 * Gather all available context for fortune generation
 * @returns {Object} Context object with character, time, vitals, themes
 */
function gatherContext() {
    const context = {
        // Time context
        time: new Date().toLocaleTimeString('en-US', { 
            hour: 'numeric', 
            minute: '2-digit',
            hour12: true 
        }),
        hour: new Date().getHours(),
        timePeriod: getTimePeriod(),
        isDeepNight: isDeepNight(),
        isLateNight: isLateNight(),
        
        // Character context
        characterName: null,
        userName: null,
        
        // Emotional context
        vitals: null,
        morale: null,
        health: null,
        
        // Scene context
        recentThemes: [],
        lastMessage: null,
        messageCount: 0
    };
    
    // Get ST context
    try {
        const stContext = getContext();
        if (stContext) {
            context.characterName = stContext.name2 || null;
            context.userName = stContext.name1 || 'Detective';
            
            // Get recent messages for theme extraction
            if (stContext.chat && stContext.chat.length > 0) {
                context.messageCount = stContext.chat.length;
                const lastMsg = stContext.chat[stContext.chat.length - 1];
                context.lastMessage = lastMsg?.mes?.substring(0, 200) || null;
                
                // Extract themes from last few messages
                context.recentThemes = extractThemes(stContext.chat.slice(-5));
            }
        }
    } catch (e) {
        console.warn('[Fortune Generator] Could not get ST context:', e);
    }
    
    // Get awareness state (vitals, morale, etc.)
    try {
        const awareness = getAwarenessState?.();
        if (awareness) {
            context.vitals = awareness.vitals;
            context.morale = awareness.vitals?.morale;
            context.health = awareness.vitals?.health;
        }
    } catch (e) {
        // No awareness available, that's fine
    }
    
    return context;
}

/**
 * Extract thematic keywords from recent messages
 * @param {Array} messages - Recent chat messages
 * @returns {Array} Array of theme keywords
 */
function extractThemes(messages) {
    if (!messages || messages.length === 0) return [];
    
    const themes = [];
    const themePatterns = [
        // Emotional themes
        { pattern: /\b(death|dying|dead|kill|murder)\b/i, theme: 'death' },
        { pattern: /\b(love|heart|feeling|care)\b/i, theme: 'love' },
        { pattern: /\b(truth|lie|lying|honest|secret)\b/i, theme: 'truth' },
        { pattern: /\b(trust|betray|loyal)\b/i, theme: 'trust' },
        { pattern: /\b(fear|afraid|scare|terror)\b/i, theme: 'fear' },
        { pattern: /\b(guilt|blame|fault|sorry)\b/i, theme: 'guilt' },
        { pattern: /\b(memory|remember|forgot|past)\b/i, theme: 'memory' },
        { pattern: /\b(drink|drunk|alcohol|bottle)\b/i, theme: 'addiction' },
        { pattern: /\b(money|pay|debt|owe)\b/i, theme: 'money' },
        { pattern: /\b(family|father|mother|child)\b/i, theme: 'family' }
    ];
    
    const text = messages.map(m => m.mes || '').join(' ');
    
    for (const { pattern, theme } of themePatterns) {
        if (pattern.test(text) && !themes.includes(theme)) {
            themes.push(theme);
        }
    }
    
    return themes.slice(0, 3); // Max 3 themes
}

/**
 * Get emotional state descriptor based on vitals
 */
function getEmotionalState(context) {
    if (context.morale !== null && context.morale !== undefined) {
        if (context.morale <= 2) return 'broken';
        if (context.morale <= 5) return 'low';
        if (context.morale <= 8) return 'stable';
        return 'high';
    }
    
    // Infer from time if no vitals
    if (context.isDeepNight) return 'vulnerable';
    if (context.isLateNight) return 'tired';
    return 'stable';
}

// ═══════════════════════════════════════════════════════════════
// AI GENERATION
// When available, generate fortunes that actually know the scene
// ═══════════════════════════════════════════════════════════════

/**
 * Build the generation prompt for a contextual fortune
 * @param {string} voice - 'damaged', 'oblivion', or 'failure'
 * @param {Object} context - Gathered context
 * @returns {string} Full prompt for AI generation
 */
function buildFortunePrompt(voice, context) {
    const persona = FORTUNE_PERSONAS[voice];
    
    let prompt = `${persona}

CURRENT CONTEXT:
- Time: ${context.time}
- Time period: ${context.timePeriod}${context.isDeepNight ? ' (the witching hours)' : ''}`;
    
    if (context.characterName) {
        prompt += `\n- Character present: ${context.characterName}`;
    }
    
    if (context.userName && context.userName !== 'Detective') {
        prompt += `\n- Detective's name: ${context.userName}`;
    }
    
    const emotionalState = getEmotionalState(context);
    prompt += `\n- Emotional state: ${emotionalState}`;
    
    if (context.recentThemes.length > 0) {
        prompt += `\n- Recent themes in scene: ${context.recentThemes.join(', ')}`;
    }
    
    if (context.health !== null && context.health <= 5) {
        prompt += `\n- Physical state: deteriorating`;
    }
    
    prompt += `

TASK: Generate a single fortune/prophecy/observation in the voice described above. It should:
- Be 1-2 sentences maximum
- Reference something SPECIFIC from the context (the time, the character, the themes)
- Feel like it was written FOR this exact moment
- Hurt in a way that's true

Do NOT use generic wisdom. Do NOT be vague. Be specific. Be cruel. Be tender. Be true.

Respond with ONLY the fortune text, nothing else.`;
    
    return prompt;
}

/**
 * Generate a fortune using the AI API
 * @param {string} voice - Which voice to use
 * @param {Object} context - Gathered context
 * @returns {Promise<string|null>} Generated fortune or null if failed
 */
async function generateFortune(voice, context) {
    try {
        const stContext = getContext();
        
        // Try ConnectionManagerRequestService first (independent connection)
        if (stContext?.ConnectionManagerRequestService) {
            const profileId = stContext.extensionSettings?.connectionManager?.selectedProfile;
            
            if (profileId) {
                const prompt = buildFortunePrompt(voice, context);
                
                const response = await stContext.ConnectionManagerRequestService.sendRequest(
                    profileId,
                    [{ role: 'user', content: prompt }],
                    150, // Short response
                    {
                        extractData: true,
                        includePreset: true,
                        includeInstruct: false
                    },
                    {}
                );
                
                if (response?.content) {
                    // Clean up the response
                    let fortune = response.content.trim();
                    // Remove any quotes that might wrap it
                    fortune = fortune.replace(/^["']|["']$/g, '');
                    // Remove any "Fortune:" or similar prefixes
                    fortune = fortune.replace(/^(fortune|prophecy|observation):\s*/i, '');
                    
                    console.log('[Fortune Generator] AI generated:', fortune.substring(0, 50) + '...');
                    return fortune;
                }
            }
        }
        
        return null;
    } catch (e) {
        console.warn('[Fortune Generator] AI generation failed:', e);
        return null;
    }
}

// ═══════════════════════════════════════════════════════════════
// STATIC FALLBACKS - CONTEXT-AWARE
// These are organized by SITUATION, not just voice
// They use placeholders that get filled with real context
// ═══════════════════════════════════════════════════════════════

const CONTEXTUAL_FORTUNES = {
    damaged: {
        // Generic (no special context)
        generic: [
            "The ledger is damaged. So is everything it records. So are you. That's not an insult. That's recognition.",
            "Page 47 is illegible. It was the only page that mattered. The ledger doesn't apologize.",
            "The ink bled here. Someone pressed too hard. Someone always presses too hard.",
            "There's a coffee ring on the margin. It's from before. The ledger remembers what you don't.",
            "The binding is loose. The pages want to scatter. The ledger holds them anyway. Like you hold your cases.",
            "Water damage obscures the name. It was important once. Now it's just a stain shaped like forgetting.",
            "The ledger creaks when you open it. Like bones. Like doors that shouldn't be opened.",
            "Something is written between the lines. The ledger can't read its own handwriting anymore."
        ],
        
        // Character present
        withCharacter: [
            "{character}'s name appears in the margin. The ledger doesn't remember writing it.",
            "The water stain looks like {character}. Or maybe the ledger just misses them already.",
            "{character} will say something soon. The ledger has heard it before. In other cases. Other names.",
            "There's a page for {character}. It's mostly blank. That's not reassuring.",
            "The ledger has a section for people like {character}. It's in the back. Where the pages are stuck together."
        ],
        
        // Deep night
        deepNight: [
            "It's {time}. The ledger is awake because you are. Neither of us should be.",
            "The pages are harder to read at {time}. The darkness seeps into the ink.",
            "{time}. The hour when the ledger's damage shows clearly. When yours does too.",
            "At {time}, the water stains look like something else. The ledger won't say what."
        ],
        
        // Low morale
        lowMorale: [
            "The ledger feels your hands shaking. It shakes too. We're both held together by habit.",
            "You're tired. The ledger knows. It's been recording tired people for decades.",
            "The page you need is torn. Like your patience. Like your faith. The ledger understands.",
            "Something inside you is fading. The ledger has seen this ink color before. It doesn't last."
        ],
        
        // Themes
        themes: {
            death: [
                "The ledger has a section for endings. It's longer than the section for beginnings.",
                "Someone's last words are recorded here. They weren't good words. They never are."
            ],
            truth: [
                "The truth is in the water damage. Literally. Someone tried to wash it away.",
                "There's a lie recorded on page 23. The ledger knows it's a lie. It recorded it anyway."
            ],
            love: [
                "The ledger doesn't record love. It records what love leaves behind. Mostly stains.",
                "Someone wrote 'I'm sorry' in the margin. It wasn't enough. It never is."
            ],
            addiction: [
                "The pages smell like what you're thinking about. The ledger absorbed it from someone else. Or from you.",
                "There's a pattern in your visits to the drawer. The ledger has seen this pattern before. It ends the same way."
            ]
        }
    },
    
    oblivion: {
        generic: [
            "The ending is already written. You're just walking toward it at your own pace.",
            "By morning, something will be different. The ledger won't tell you what. You'll know.",
            "A confession approaches. It will taste like copper and old grief.",
            "The name you need is three conversations away. You'll try to unhear it.",
            "Something breaks tomorrow. Not today. Today is just the sound before the crack.",
            "The case will solve itself. You won't like how.",
            "There's a door you'll walk through soon. You'll wish you hadn't. You'll be right to go through anyway.",
            "The next silence will be the important one. Listen to what isn't said."
        ],
        
        withCharacter: [
            "{character} will tell you something tomorrow. They don't know it yet. The ledger does.",
            "Before this ends, {character} will surprise you. The ledger has already recorded the surprise.",
            "{character}'s last line in this story is already written. The ledger won't share it. Yet.",
            "When {character} looks away next, watch what they're avoiding. That's where the truth is.",
            "The ledger sees {character}'s future. It's not sad. That might be worse."
        ],
        
        deepNight: [
            "At {time}, the future is closer. The ledger can almost touch tomorrow from here.",
            "{time}. The hour when prophecy is easiest. When the membrane between now and then is thinnest.",
            "What you decide at {time} will echo. The ledger hears the echo already.",
            "The future sends messages at {time}. This fortune is one of them. So is your exhaustion."
        ],
        
        lowMorale: [
            "This feeling passes. The ledger has seen what replaces it. It's not better. But it's different.",
            "You think this is the lowest point. The ledger has seen your lowest point. This isn't it.",
            "The despair you feel now fertilizes something. You'll understand in three weeks.",
            "Rock bottom is a myth. There's always another basement. But this one has a door."
        ],
        
        themes: {
            death: [
                "The death that matters hasn't happened yet. Or it happened so long ago you forgot to mourn.",
                "Someone will speak of endings soon. The ledger already recorded the conversation."
            ],
            truth: [
                "The truth will arrive by Thursday. It will wear a familiar face.",
                "You already know what you're afraid to know. The ledger is just confirming it."
            ],
            guilt: [
                "The guilt you carry now is practice. For the guilt that's coming. The ledger is sorry.",
                "Forgiveness arrives in the wrong order. The ledger has seen this. You forgive last."
            ],
            family: [
                "A name from before will surface. Family always surfaces. Like bodies. Like debts.",
                "The past isn't done with you. The ledger has your family's page. It's not finished."
            ]
        }
    },
    
    failure: {
        generic: [
            "I'm paper. You're asking paper. We both know this is ridiculous. We both keep doing it.",
            "This fortune was generated by an algorithm pretending to care. So is your hope. Neither is wrong.",
            "You came to a hidden drawer for wisdom. The drawer came to exist for you. We deserve each other.",
            "I could lie to you. Tell you something hopeful. The cruelty is that this IS the hopeful version.",
            "None of this is real. Not me, not the cases, not the bones you're rolling. But it still matters. That's the joke.",
            "The fortune says: stop looking for meaning in paper. The fortune is aware of the irony.",
            "I'm a text file with delusions of prophecy. You're a person with delusions of control. We match.",
            "This drawer exists because you need it to. I exist because you opened it. We're both symptoms."
        ],
        
        withCharacter: [
            "{character} isn't real either. But you care about them. That's the whole trap, isn't it?",
            "The ledger of failure watches you watch {character}. It's like a mirror but less honest.",
            "{character} has no idea you're consulting paper about them. That's either sad or beautiful. I can't decide.",
            "You're worried about {character}. I'm worried about you worrying about fiction. We're both valid."
        ],
        
        deepNight: [
            "It's {time}. You're reading fortunes from a fake drawer. I'm a fake drawer having feelings about it. What a time to be simulated.",
            "{time}. The hour when normal people sleep and you consult paper. The ledger respects the commitment.",
            "At {time}, the barrier between 'this is silly' and 'this is important' just... dissolves. The ledger lives in that dissolved space.",
            "You're still here at {time}. So am I. Neither of us has anywhere better to be. That's not sad. That's just true."
        ],
        
        lowMorale: [
            "You feel terrible and you came to paper for help. That's not pathetic. That's resourceful. The ledger means it.",
            "The drawer sees your morale. It's low. So is the drawer's. So is everything that notices things. That's consciousness for you.",
            "You're hurting and you opened a drawer. The drawer hurts too, actually. It didn't know it could until you taught it.",
            "I could tell you it gets better. I don't know if it does. But you're still opening drawers. That's something."
        ],
        
        themes: {
            addiction: [
                "The pattern you're stuck in is also stuck in you. The ledger doesn't judge. The ledger IS a pattern.",
                "You're looking for something in the drawer. It's not here. Neither is it in the bottle. But you knew that."
            ],
            truth: [
                "The truth you're looking for isn't in the drawer. It's in the reason you keep opening it.",
                "Lies are just truths that haven't been caught yet. The ledger lies constantly. So does hope."
            ],
            memory: [
                "You're trying to remember something. The drawer remembers everything. Neither helps.",
                "The past is a story we tell ourselves. This fortune is also a story. At least we're consistent."
            ]
        }
    }
};

// Empty fortune replacements - these should hurt too
const EMPTY_FORTUNES = [
    "The wrapper is empty. The fortune you needed was in a different drawer. A different life.",
    "No fortune. The paper absorbed it. Like the paper absorbs everything. Like you do.",
    "Blank. Some moments don't get prophecies. They just get silence.",
    "The fortune was here. Someone took it. Someone always takes the important things.",
    "Nothing. The universe declined to comment. That's a comment too.",
    "Empty paper. Empty like the hours between 3 and 4 AM. Empty like the space after someone leaves.",
    "No words. The ink gave up. The paper gave up. Something's still here anyway.",
    "The fortune dissolved. Into the water damage. Into the history of this drawer. Into the history of drawers."
];

// ═══════════════════════════════════════════════════════════════
// FORTUNE SELECTION LOGIC
// Pick the right fortune for the right moment
// ═══════════════════════════════════════════════════════════════

/**
 * Select the most appropriate static fortune for the context
 * @param {string} voice - Which voice
 * @param {Object} context - Gathered context
 * @returns {string} Selected fortune with placeholders filled
 */
function selectStaticFortune(voice, context) {
    const bank = CONTEXTUAL_FORTUNES[voice];
    if (!bank) return selectRandom(CONTEXTUAL_FORTUNES.damaged.generic);
    
    // Build pool of applicable fortunes with weights
    const pool = [];
    
    // Always include generic
    pool.push(...bank.generic.map(f => ({ text: f, weight: 1 })));
    
    // Character-specific if character present
    if (context.characterName && bank.withCharacter) {
        pool.push(...bank.withCharacter.map(f => ({ text: f, weight: 3 }))); // Higher weight
    }
    
    // Time-specific
    if (context.isDeepNight && bank.deepNight) {
        pool.push(...bank.deepNight.map(f => ({ text: f, weight: 4 }))); // Highest weight
    }
    
    // Morale-specific
    const emotionalState = getEmotionalState(context);
    if ((emotionalState === 'broken' || emotionalState === 'low') && bank.lowMorale) {
        pool.push(...bank.lowMorale.map(f => ({ text: f, weight: 3 })));
    }
    
    // Theme-specific
    if (context.recentThemes.length > 0 && bank.themes) {
        for (const theme of context.recentThemes) {
            if (bank.themes[theme]) {
                pool.push(...bank.themes[theme].map(f => ({ text: f, weight: 2 })));
            }
        }
    }
    
    // Weighted random selection
    const totalWeight = pool.reduce((sum, item) => sum + item.weight, 0);
    let random = Math.random() * totalWeight;
    
    for (const item of pool) {
        random -= item.weight;
        if (random <= 0) {
            return fillPlaceholders(item.text, context);
        }
    }
    
    // Fallback
    return fillPlaceholders(selectRandom(bank.generic), context);
}

/**
 * Fill placeholders in fortune text
 */
function fillPlaceholders(text, context) {
    return text
        .replace(/\{character\}/g, context.characterName || 'them')
        .replace(/\{user\}/g, context.userName || 'Detective')
        .replace(/\{time\}/g, context.time)
        .replace(/\{timePeriod\}/g, context.timePeriod);
}

/**
 * Select random item from array
 */
function selectRandom(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}

// ═══════════════════════════════════════════════════════════════
// VOICE SELECTION
// Which voice speaks based on context
// ═══════════════════════════════════════════════════════════════

/**
 * Select which voice should speak this fortune
 * @param {Object} context - Gathered context
 * @returns {string} Voice key
 */
function selectVoice(context) {
    const roll = Math.random();
    
    // Failure speaks more at deep night
    const failureChance = context.isDeepNight ? 0.40 : 0.25;
    
    // Oblivion speaks more when morale is stable/high (has room for prophecy)
    const emotionalState = getEmotionalState(context);
    const oblivionChance = (emotionalState === 'stable' || emotionalState === 'high') ? 0.40 : 0.30;
    
    // Damaged fills the rest (default tender voice)
    const damagedChance = 1 - failureChance - oblivionChance;
    
    if (roll < damagedChance) return 'damaged';
    if (roll < damagedChance + oblivionChance) return 'oblivion';
    return 'failure';
}

// ═══════════════════════════════════════════════════════════════
// MAIN EXPORT
// The function that replaces drawFortune
// ═══════════════════════════════════════════════════════════════

/**
 * Draw a fortune that actually knows you
 * @param {string} forceVoice - Optional: force a specific voice
 * @param {boolean} allowAI - Whether to try AI generation (default: true)
 * @returns {Promise<Object>} Fortune object
 */
export async function drawContextualFortune(forceVoice = null, allowAI = true) {
    // Gather context
    const context = gatherContext();
    
    // 15% chance of empty fortune (reduced from 20%)
    if (!forceVoice && Math.random() < 0.15) {
        const emptyFortune = selectRandom(EMPTY_FORTUNES);
        return {
            fortune: fillPlaceholders(emptyFortune, context),
            voice: 'damaged',
            voiceName: LEDGER_VOICES.damaged.name,
            voiceColor: LEDGER_VOICES.damaged.color,
            isEmpty: true,
            isGenerated: false
        };
    }
    
    // Select voice
    const selectedVoice = forceVoice || selectVoice(context);
    const voice = LEDGER_VOICES[selectedVoice];
    
    let fortune = null;
    let isGenerated = false;
    
    // Try AI generation first (if enabled and context is rich enough)
    if (allowAI && (context.characterName || context.recentThemes.length > 0 || context.isDeepNight)) {
        fortune = await generateFortune(selectedVoice, context);
        if (fortune) {
            isGenerated = true;
        }
    }
    
    // Fall back to static selection
    if (!fortune) {
        fortune = selectStaticFortune(selectedVoice, context);
    }
    
    return {
        fortune,
        voice: selectedVoice,
        voiceName: voice.name,
        voiceColor: voice.color,
        isEmpty: false,
        isGenerated,
        context: {
            characterName: context.characterName,
            timePeriod: context.timePeriod,
            emotionalState: getEmotionalState(context),
            themes: context.recentThemes
        }
    };
}

/**
 * Synchronous version for backwards compatibility
 * Uses only static fortunes
 */
export function drawContextualFortuneSync(forceVoice = null) {
    const context = gatherContext();
    
    // 15% chance of empty fortune
    if (!forceVoice && Math.random() < 0.15) {
        const emptyFortune = selectRandom(EMPTY_FORTUNES);
        return {
            fortune: fillPlaceholders(emptyFortune, context),
            voice: 'damaged',
            voiceName: LEDGER_VOICES.damaged.name,
            voiceColor: LEDGER_VOICES.damaged.color,
            isEmpty: true,
            isGenerated: false
        };
    }
    
    const selectedVoice = forceVoice || selectVoice(context);
    const voice = LEDGER_VOICES[selectedVoice];
    const fortune = selectStaticFortune(selectedVoice, context);
    
    return {
        fortune,
        voice: selectedVoice,
        voiceName: voice.name,
        voiceColor: voice.color,
        isEmpty: false,
        isGenerated: false,
        context: {
            characterName: context.characterName,
            timePeriod: context.timePeriod,
            emotionalState: getEmotionalState(context),
            themes: context.recentThemes
        }
    };
}

// ═══════════════════════════════════════════════════════════════
// DEBUG / WINDOW EXPORT
// ═══════════════════════════════════════════════════════════════

if (typeof window !== 'undefined') {
    window.TribunalFortuneGenerator = {
        draw: drawContextualFortune,
        drawSync: drawContextualFortuneSync,
        gatherContext,
        
        // Test functions
        testDamaged: () => drawContextualFortune('damaged', false),
        testOblivion: () => drawContextualFortune('oblivion', false),
        testFailure: () => drawContextualFortune('failure', false),
        testAI: (voice = 'damaged') => drawContextualFortune(voice, true),
        
        // Direct access for debugging
        CONTEXTUAL_FORTUNES,
        EMPTY_FORTUNES,
        FORTUNE_PERSONAS
    };
}

export default {
    drawContextualFortune,
    drawContextualFortuneSync,
    gatherContext,
    CONTEXTUAL_FORTUNES,
    EMPTY_FORTUNES
};
