/**
 * The Tribunal - Thought Generation Prompt Builder
 * Generates Disco Elysium-style thoughts based on chat context
 */

/**
 * Build the system prompt for thought generation
 * @param {Object} playerContext - { perspective: 'observer'|'participant', identity: string }
 * @param {Object} themeData - Current theme counters
 * @returns {string} System prompt
 */
export function buildThoughtSystemPrompt(playerContext, themeData) {
    const perspectiveGuide = playerContext.perspective === 'observer'
        ? `The player is an OBSERVER watching events unfold. Use "you watch", "you see them".`
        : `The player is a PARTICIPANT. Use "you feel", "you remember".`;

    const identityGuide = playerContext.identity
        ? `Player identity: "${playerContext.identity}".`
        : '';

    // Get top 3 themes for flavor
    const topThemes = Object.entries(themeData || {})
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3)
        .map(([theme]) => theme)
        .join(', ');

    return `You generate Disco Elysium THOUGHTS for a Thought Cabinet.

${perspectiveGuide}
${identityGuide}
${topThemes ? `Themes: ${topThemes}` : ''}

## CRITICAL LENGTH RULES - FOLLOW EXACTLY

‚ö†Ô∏è MAXIMUM 50 WORDS for problemText
‚ö†Ô∏è MAXIMUM 50 WORDS for solutionText
‚ö†Ô∏è Total response must be under 400 tokens

If you exceed these limits, the response will be cut off and fail.

## STRUCTURE

problemText: The obsessive question (2-3 sentences MAX)
solutionText: The "answer" arrived at (2-3 sentences MAX)

## STYLE

- Punchy, evocative, specific
- No filler or repetition
- End solutionText with impact

## OUTPUT FORMAT - JSON ONLY

{
    "name": "THOUGHT NAME",
    "icon": "emoji",
    "problemText": "2-3 sentences max.",
    "solutionText": "2-3 sentences max.",
    "researchBonus": { "skillname": { "value": -1, "flavor": "Short reason" } },
    "internalizedBonus": { "skillname": { "value": 2, "flavor": "Short reason" } }
}

NO markdown fences. NO extra text. ONLY the JSON object.`;
}

/**
 * Build the user prompt with specific context
 * @param {string} concept - User-provided concept/obsession OR auto-extracted theme
 * @param {string} chatContext - Recent chat excerpt for context
 * @param {Object} options - Additional options
 * @returns {string} User prompt
 */
export function buildThoughtUserPrompt(concept, chatContext, options = {}) {
    const { 
        autoGenerated = false,
        triggeringThemes = [],
        emotionalTone = null 
    } = options;

    let prompt = '';

    if (autoGenerated) {
        prompt += `Generate a thought from this scene.

THEMES: ${triggeringThemes.join(', ')}
${emotionalTone ? `TONE: ${emotionalTone}` : ''}

SCENE:
"""
${chatContext?.substring(0, 800) || 'No context'}
"""`;
    } else {
        prompt += `Generate a thought about: "${concept}"

${chatContext ? `SCENE CONTEXT:
"""
${chatContext.substring(0, 800)}
"""` : ''}`;
    }

    prompt += `

REMEMBER:
- problemText: MAX 50 words (2-3 sentences)
- solutionText: MAX 50 words (2-3 sentences)
- Output ONLY valid JSON, no markdown fences
- Be concise or the response will be cut off`;

    return prompt;
}

/**
 * Parse and validate the API response
 * @param {string} response - Raw API response
 * @returns {Object|null} Parsed thought or null if invalid
 */
export function parseThoughtResponse(response) {
    if (!response) {
        console.error('[Tribunal] No response to parse');
        return null;
    }
    
    try {
        let cleaned = response.trim();
        
        // Strip markdown code fences (various formats)
        // Handle ```json, ```JSON, ``` with or without newlines
        cleaned = cleaned.replace(/^```(?:json|JSON)?\s*\n?/i, '');
        cleaned = cleaned.replace(/\n?```\s*$/i, '');
        
        // Also handle if there's trailing content after the JSON
        // Find the last } and truncate there
        const lastBrace = cleaned.lastIndexOf('}');
        if (lastBrace !== -1 && lastBrace < cleaned.length - 1) {
            cleaned = cleaned.substring(0, lastBrace + 1);
        }
        
        cleaned = cleaned.trim();
        
        // Debug log
        console.log('[Tribunal] Cleaned JSON:', cleaned.substring(0, 200) + '...');

        const thought = JSON.parse(cleaned);

        // Accept both field name variants
        if (thought.problem && !thought.problemText) {
            thought.problemText = thought.problem;
        }
        if (thought.solution && !thought.solutionText) {
            thought.solutionText = thought.solution;
        }

        // Validate required fields
        if (!thought.name) {
            console.warn('[Tribunal] Thought missing name');
            return null;
        }
        if (!thought.problemText) {
            console.warn('[Tribunal] Thought missing problemText');
            return null;
        }
        if (!thought.solutionText) {
            console.warn('[Tribunal] Thought missing solutionText');
            return null;
        }

        // Normalize name to uppercase
        thought.name = thought.name.toUpperCase();
        
        // Default icon if missing
        if (!thought.icon) {
            thought.icon = 'üí≠';
        }

        // Normalize bonus formats
        if (Array.isArray(thought.internalizeBonuses) && !thought.internalizedBonus) {
            thought.internalizedBonus = {};
            for (const bonus of thought.internalizeBonuses) {
                const match = bonus.match(/([+-]\d+)\s+(\w+)(?::\s*(.+))?/);
                if (match) {
                    thought.internalizedBonus[match[2].toLowerCase()] = {
                        value: parseInt(match[1]),
                        flavor: match[3] || ''
                    };
                }
            }
        }

        if (typeof thought.researchBonus === 'string') {
            const match = thought.researchBonus.match(/([+-]\d+)\s+(\w+)(?::\s*(.+))?/);
            if (match) {
                thought.researchBonus = {
                    [match[2].toLowerCase()]: {
                        value: parseInt(match[1]),
                        flavor: match[3] || ''
                    }
                };
            }
        }

        // Add metadata
        thought.isGenerated = true;
        thought.isCustom = true;
        thought.generatedAt = Date.now();

        return thought;

    } catch (e) {
        console.error('[Tribunal] JSON parse failed:', e.message);
        console.error('[Tribunal] Raw response (first 500 chars):', response?.substring?.(0, 500));
        return null;
    }
}

/**
 * Convert parsed thought to cabinet-compatible format
 * @param {Object} thought - Parsed thought from API
 * @param {string} thoughtId - Unique ID for this thought
 * @returns {Object} Cabinet-ready thought object
 */
export function formatThoughtForCabinet(thought, thoughtId) {
    return {
        id: thoughtId,
        name: thought.name,
        icon: thought.icon || 'üí≠',
        
        problemText: thought.problemText,
        solutionText: thought.solutionText,
        
        researchBonus: thought.researchBonus || {},
        internalizedBonus: thought.internalizedBonus || {},
        
        flavorEffect: thought.flavorEffect || null,
        
        isGenerated: true,
        isCustom: true,
        generatedAt: thought.generatedAt,
        
        researchTime: thought.researchTime || 10,
    };
}
