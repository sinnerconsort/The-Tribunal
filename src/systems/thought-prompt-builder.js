/**
 * The Tribunal - Thought Generation Prompt Builder
 * Generates Disco Elysium-style thoughts based on chat context
 */

/**
 * Build the system prompt for thought generation
 * @param {Object} playerContext - { perspective: 'observer'|'participant', identity: string }
 * @param {Object} themeData - Current theme counters
 * @returns {string} System prompt
 */
export function buildThoughtSystemPrompt(playerContext, themeData) {
    const perspectiveGuide = playerContext.perspective === 'observer'
        ? `The player is an OBSERVER watching events unfold. Use "you watch", "you see them".`
        : `The player is a PARTICIPANT. Use "you feel", "you remember".`;

    const identityGuide = playerContext.identity
        ? `Player identity: "${playerContext.identity}".`
        : '';

    // Get top 3 themes for flavor
    const topThemes = Object.entries(themeData || {})
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3)
        .map(([theme]) => theme)
        .join(', ');

    return `You generate Disco Elysium THOUGHTS for a Thought Cabinet.

${perspectiveGuide}
${identityGuide}
${topThemes ? `Themes: ${topThemes}` : ''}

## CRITICAL FORMAT RULES

‚ö†Ô∏è Output ONLY valid JSON - no markdown, no code fences
‚ö†Ô∏è Keep problemText and solutionText on SINGLE LINES (no line breaks inside strings)
‚ö†Ô∏è Use spaces, not newlines, between sentences
‚ö†Ô∏è Maximum 50 words per text field

## STRUCTURE

problemText: The obsessive question (2-3 sentences, ONE LINE)
solutionText: The "answer" arrived at (2-3 sentences, ONE LINE)

## OUTPUT FORMAT

{"name":"THOUGHT NAME","icon":"emoji","problemText":"All text on one line. No line breaks.","solutionText":"All text on one line. No line breaks.","researchBonus":{"skillname":{"value":-1,"flavor":"reason"}},"internalizedBonus":{"skillname":{"value":2,"flavor":"reason"}}}`;
}

/**
 * Build the user prompt with specific context
 * @param {string} concept - User-provided concept/obsession OR auto-extracted theme
 * @param {string} chatContext - Recent chat excerpt for context
 * @param {Object} options - Additional options
 * @returns {string} User prompt
 */
export function buildThoughtUserPrompt(concept, chatContext, options = {}) {
    const { 
        autoGenerated = false,
        triggeringThemes = [],
        emotionalTone = null 
    } = options;

    let prompt = '';

    if (autoGenerated) {
        prompt += `Generate a thought from this scene.

THEMES: ${triggeringThemes.join(', ')}
${emotionalTone ? `TONE: ${emotionalTone}` : ''}

SCENE:
"""
${chatContext?.substring(0, 800) || 'No context'}
"""`;
    } else {
        prompt += `Generate a thought about: "${concept}"

${chatContext ? `SCENE CONTEXT:
"""
${chatContext.substring(0, 800)}
"""` : ''}`;
    }

    prompt += `

CRITICAL: Output raw JSON only. NO newlines inside string values. Keep all text on single lines.`;

    return prompt;
}

/**
 * Sanitize JSON string to fix common LLM output issues
 * @param {string} jsonStr - Raw JSON string
 * @returns {string} Sanitized JSON string
 */
function sanitizeJSON(jsonStr) {
    if (!jsonStr) return jsonStr;
    
    // Step 1: Replace literal newlines inside string values with spaces
    // This regex finds content between quotes and replaces newlines
    let result = jsonStr;
    
    // First, normalize all types of line endings
    result = result.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    
    // Replace newlines that appear inside JSON string values with spaces
    // We do this by finding all string contents and processing them
    let inString = false;
    let escaped = false;
    let output = '';
    
    for (let i = 0; i < result.length; i++) {
        const char = result[i];
        
        if (escaped) {
            output += char;
            escaped = false;
            continue;
        }
        
        if (char === '\\') {
            output += char;
            escaped = true;
            continue;
        }
        
        if (char === '"') {
            inString = !inString;
            output += char;
            continue;
        }
        
        if (inString && char === '\n') {
            // Replace newline inside string with space
            output += ' ';
            continue;
        }
        
        output += char;
    }
    
    return output;
}

/**
 * Parse and validate the API response
 * @param {string} response - Raw API response
 * @returns {Object|null} Parsed thought or null if invalid
 */
export function parseThoughtResponse(response) {
    if (!response) {
        console.error('[Tribunal] No response to parse');
        return null;
    }
    
    try {
        let cleaned = response.trim();
        
        // Strip markdown code fences (various formats)
        cleaned = cleaned.replace(/^```(?:json|JSON)?\s*\n?/i, '');
        cleaned = cleaned.replace(/\n?```\s*$/i, '');
        
        // Find JSON boundaries - look for first { and last }
        const firstBrace = cleaned.indexOf('{');
        const lastBrace = cleaned.lastIndexOf('}');
        
        if (firstBrace === -1 || lastBrace === -1 || lastBrace <= firstBrace) {
            console.error('[Tribunal] No valid JSON object found in response');
            return null;
        }
        
        cleaned = cleaned.substring(firstBrace, lastBrace + 1);
        
        // Sanitize the JSON (fix newlines inside strings, etc.)
        cleaned = sanitizeJSON(cleaned);
        
        // Debug log
        console.log('[Tribunal] Sanitized JSON (first 300 chars):', cleaned.substring(0, 300));

        const thought = JSON.parse(cleaned);

        // Accept both field name variants
        if (thought.problem && !thought.problemText) {
            thought.problemText = thought.problem;
        }
        if (thought.solution && !thought.solutionText) {
            thought.solutionText = thought.solution;
        }

        // Validate required fields
        if (!thought.name) {
            console.warn('[Tribunal] Thought missing name');
            return null;
        }
        if (!thought.problemText) {
            console.warn('[Tribunal] Thought missing problemText');
            return null;
        }
        if (!thought.solutionText) {
            console.warn('[Tribunal] Thought missing solutionText');
            return null;
        }

        // Normalize name to uppercase
        thought.name = thought.name.toUpperCase();
        
        // Default icon if missing
        if (!thought.icon) {
            thought.icon = 'üí≠';
        }

        // Normalize bonus formats
        if (Array.isArray(thought.internalizeBonuses) && !thought.internalizedBonus) {
            thought.internalizedBonus = {};
            for (const bonus of thought.internalizeBonuses) {
                const match = bonus.match(/([+-]\d+)\s+(\w+)(?::\s*(.+))?/);
                if (match) {
                    thought.internalizedBonus[match[2].toLowerCase()] = {
                        value: parseInt(match[1]),
                        flavor: match[3] || ''
                    };
                }
            }
        }

        if (typeof thought.researchBonus === 'string') {
            const match = thought.researchBonus.match(/([+-]\d+)\s+(\w+)(?::\s*(.+))?/);
            if (match) {
                thought.researchBonus = {
                    [match[2].toLowerCase()]: {
                        value: parseInt(match[1]),
                        flavor: match[3] || ''
                    }
                };
            }
        }

        // Add metadata
        thought.isGenerated = true;
        thought.isCustom = true;
        thought.generatedAt = Date.now();

        return thought;

    } catch (e) {
        console.error('[Tribunal] JSON parse failed:', e.message);
        console.error('[Tribunal] Raw response (first 500 chars):', response?.substring?.(0, 500));
        return null;
    }
}

/**
 * Convert parsed thought to cabinet-compatible format
 * @param {Object} thought - Parsed thought from API
 * @param {string} thoughtId - Unique ID for this thought
 * @returns {Object} Cabinet-ready thought object
 */
export function formatThoughtForCabinet(thought, thoughtId) {
    return {
        id: thoughtId,
        name: thought.name,
        icon: thought.icon || 'üí≠',
        
        problemText: thought.problemText,
        solutionText: thought.solutionText,
        
        researchBonus: thought.researchBonus || {},
        internalizedBonus: thought.internalizedBonus || {},
        
        flavorEffect: thought.flavorEffect || null,
        
        isGenerated: true,
        isCustom: true,
        generatedAt: thought.generatedAt,
        
        researchTime: thought.researchTime || 10,
    };
}
