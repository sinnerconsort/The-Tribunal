/**
 * The Tribunal - Thought Generation Prompt Builder
 * Generates Disco Elysium-style thoughts based on chat context
 */

/**
 * Build the system prompt for thought generation
 * @param {Object} playerContext - { perspective: 'observer'|'participant', identity: string }
 * @param {Object} themeData - Current theme counters
 * @returns {string} System prompt
 */
export function buildThoughtSystemPrompt(playerContext, themeData) {
    const perspectiveGuide = playerContext.perspective === 'observer'
        ? `The player is an OBSERVER - an outside consciousness watching events unfold. Frame thoughts as reactions to what they're witnessing, not experiencing directly. Use "you watch", "you see them", "this reminds you of".`
        : `The player is a PARTICIPANT - they ARE the character. Frame thoughts as internal experiences. Use "you feel", "you remember", "your hands", "your heart".`;

    const identityGuide = playerContext.identity
        ? `The player's identity/role: "${playerContext.identity}". Incorporate this perspective naturally - their background colors how they interpret events.`
        : `No specific identity provided. Write for a general observer/participant.`;

    // Get top 3 themes for flavor
    const topThemes = Object.entries(themeData || {})
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3)
        .map(([theme, count]) => `${theme} (${count})`)
        .join(', ');

    return `You are a Disco Elysium thought generator. You create THOUGHTS for the Thought Cabinet - obsessive ideas that lodge in the player's mind during roleplay.

${perspectiveGuide}

${identityGuide}

${topThemes ? `Current dominant themes in this playthrough: ${topThemes}` : ''}

## DISCO ELYSIUM THOUGHT STRUCTURE

Each thought has TWO parts:

**PROBLEM** (While Researching)
- The obsessive question or fixation that won't let go
- Uncertain, probing, often uncomfortable
- Hooks the player with a mystery or discomfort
- 3-6 sentences, building tension

**SOLUTION** (When Internalized)  
- The "answer" the mind arrives at (may be wrong, ironic, or darkly funny)
- Resolves the tension with insight, acceptance, or delusion
- Often bittersweet, self-aware, or unexpectedly practical
- 3-6 sentences, landing on a strong final line

## ALLOWED WRITING PATTERNS

Choose ONE pattern per thought:

1. **LIST ESCALATION** (Actual Art Degree style)
   Build momentum through increasingly absurd/intense descriptors
   "Trite, contrived, mediocre, milquetoast, amateurish, infantile..."

2. **PRACTICAL SPIRAL** (Waste Land of Reality style)
   Start existential, land on weirdly specific practical advice
   "Congrats - you're sober. Eat plenty. Your coordination will improve in weeks."

3. **PROPHETIC DREAD** (Cop of the Apocalypse style)
   Build cosmic/existential weight, end with call to action
   "The world is dying. It's a fact. People need to know."

4. **SELF-AWARE COMMENTARY** (Homo-Sexual Underground style)
   Break the fourth wall about the obsession itself
   "You've thought about this for *eight hours*?! Maybe you should stop."

5. **MEMORY TRACE** (Lonesome Long Way Home style)
   Reconstruct a path, place, or moment with sensory specificity
   "Jump across the bridge. Fall over. Get up. Shuffle through courtyards..."

## CRITICAL RULES

❌ NEVER repeat a phrase or idea, even reworded
❌ NEVER loop on the same emotional beat
❌ NEVER use filler ("It's about...", "The thing is...")
❌ NEVER exceed 100 words per section

✅ Each sentence must ADD something new
✅ Build toward a punchline, revelation, or emotional peak
✅ Use *italics* for emphasis sparingly
✅ Include specific details (names, places, objects from context)
✅ End SOLUTION with a memorable final line

## OUTPUT FORMAT

Respond with ONLY valid JSON:
{
    "name": "THOUGHT NAME IN CAPS",
    "icon": "single emoji representing the thought",
    "problem": "The PROBLEM text...",
    "solution": "The SOLUTION text...",
    "researchBonus": "+1 or -1 to a relevant skill during research",
    "researchPenalty": "A negative effect while researching (optional)",
    "internalizeBonuses": [
        "+1 SkillName: brief flavor reason",
        "-1 SkillName: brief flavor reason"
    ],
    "flavorEffect": "A unique non-stat effect (optional, e.g., 'No positive effects from alcohol')"
}`;
}

/**
 * Build the user prompt with specific context
 * @param {string} concept - User-provided concept/obsession OR auto-extracted theme
 * @param {string} chatContext - Recent chat excerpt for context
 * @param {Object} options - Additional options
 * @returns {string} User prompt
 */
export function buildThoughtUserPrompt(concept, chatContext, options = {}) {
    const { 
        autoGenerated = false,
        triggeringThemes = [],
        emotionalTone = null 
    } = options;

    let prompt = '';

    if (autoGenerated) {
        prompt += `Generate a thought that emerged organically from this scene.

TRIGGERING THEMES: ${triggeringThemes.join(', ')}
${emotionalTone ? `EMOTIONAL TONE: ${emotionalTone}` : ''}

SCENE CONTEXT:
"""
${chatContext}
"""

Create a thought that captures something the player might fixate on from this scene - a question, contradiction, obsession, or realization that won't let go.`;
    } else {
        prompt += `Generate a thought based on this player-provided concept:

CONCEPT: "${concept}"

${chatContext ? `CURRENT SCENE FOR CONTEXT:
"""
${chatContext}
"""` : ''}

Create a thought that explores this concept through the lens of what's happening in the roleplay.`;
    }

    prompt += `

Remember:
- Match one of the five allowed patterns (list escalation, practical spiral, prophetic dread, self-aware commentary, or memory trace)
- NO repetition - each sentence must advance
- End with impact
- Keep it under 100 words per section
- Output valid JSON only`;

    return prompt;
}

/**
 * Parse and validate the API response
 * @param {string} response - Raw API response
 * @returns {Object|null} Parsed thought or null if invalid
 */
export function parseThoughtResponse(response) {
    try {
        // Clean up response - remove markdown code blocks if present
        let cleaned = response.trim();
        if (cleaned.startsWith('```json')) {
            cleaned = cleaned.slice(7);
        }
        if (cleaned.startsWith('```')) {
            cleaned = cleaned.slice(3);
        }
        if (cleaned.endsWith('```')) {
            cleaned = cleaned.slice(0, -3);
        }
        cleaned = cleaned.trim();

        const thought = JSON.parse(cleaned);

        // Validate required fields
        const required = ['name', 'icon', 'problem', 'solution'];
        for (const field of required) {
            if (!thought[field]) {
                console.warn(`Thought missing required field: ${field}`);
                return null;
            }
        }

        // Normalize name to uppercase
        thought.name = thought.name.toUpperCase();

        // Ensure internalizeBonuses is an array
        if (!Array.isArray(thought.internalizeBonuses)) {
            thought.internalizeBonuses = [];
        }

        // Add metadata
        thought.isGenerated = true;
        thought.generatedAt = Date.now();

        return thought;

    } catch (e) {
        console.error('Failed to parse thought response:', e);
        return null;
    }
}

/**
 * Convert parsed thought to cabinet-compatible format
 * @param {Object} thought - Parsed thought from API
 * @param {string} thoughtId - Unique ID for this thought
 * @returns {Object} Cabinet-ready thought object
 */
export function formatThoughtForCabinet(thought, thoughtId) {
    // Parse bonuses into structured format
    const bonuses = {
        research: [],
        internalized: []
    };

    // Parse research bonus (e.g., "+1 Logic" or "-1 Composure")
    if (thought.researchBonus) {
        const match = thought.researchBonus.match(/([+-]\d+)\s+(\w+)/);
        if (match) {
            bonuses.research.push({
                skill: match[2].toLowerCase(),
                value: parseInt(match[1]),
                reason: thought.researchBonus
            });
        }
    }

    // Parse internalize bonuses
    for (const bonus of thought.internalizeBonuses) {
        const match = bonus.match(/([+-]\d+)\s+(\w+):\s*(.+)/);
        if (match) {
            bonuses.internalized.push({
                skill: match[2].toLowerCase(),
                value: parseInt(match[1]),
                reason: match[3]
            });
        }
    }

    return {
        id: thoughtId,
        name: thought.name,
        icon: thought.icon,
        problem: thought.problem,
        solution: thought.solution,
        bonuses,
        researchPenalty: thought.researchPenalty || null,
        flavorEffect: thought.flavorEffect || null,
        isGenerated: true,
        generatedAt: thought.generatedAt,
        // Cabinet state
        status: 'discovered', // discovered -> researching -> internalized
        researchProgress: 0,
        researchTime: 180000, // 3 minutes default, could be dynamic
    };
}


// ═══════════════════════════════════════════════════════════════
// EXAMPLE USAGE
// ═══════════════════════════════════════════════════════════════

/*
import { callAPI } from './api-helpers.js';
import { 
    buildThoughtSystemPrompt, 
    buildThoughtUserPrompt, 
    parseThoughtResponse,
    formatThoughtForCabinet 
} from './thought-prompt-builder.js';

async function generateThought(concept, chatContext, playerContext, themeData) {
    const systemPrompt = buildThoughtSystemPrompt(playerContext, themeData);
    const userPrompt = buildThoughtUserPrompt(concept, chatContext);
    
    const response = await callAPI(systemPrompt, userPrompt);
    const parsed = parseThoughtResponse(response);
    
    if (!parsed) {
        showToast('Failed to generate thought', 'error');
        return null;
    }
    
    const thoughtId = `generated-${Date.now()}`;
    const thought = formatThoughtForCabinet(parsed, thoughtId);
    
    // Add to discovered thoughts
    thoughtCabinet.discovered.push(thought);
    saveState(getContext());
    
    return thought;
}

// Manual generation (from Generate Thought UI)
generateThought(
    "Why does Gortash care who I talk to?",
    recentChatText,
    { perspective: 'participant', identity: 'spawn of Bhaal' },
    themeCounters
);

// Auto generation (triggered by theme thresholds)
generateThought(
    null, // no concept - extract from context
    recentChatText,
    playerContext,
    themeCounters,
    { autoGenerated: true, triggeringThemes: ['jealousy', 'control'] }
);
*/
